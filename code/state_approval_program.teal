#pragma version 5

////////////////
// TODO: can we opt-in CREATOR somehow as well?

////////////////
// scratch "global" usage (this is global within the txn)
// used to make code shorter
// 100: energy
// 101: assetid
// 102: algo send txn index
// 103: app call txn index
// 104: asa send txn index
// 105: algo lock group size

////////////////
// Handle each possible OnCompletion type. We don't have to worry about
// handling ClearState, because the ClearStateProgram will execute in that
// case, not the ApprovalProgram.
// see ../manage/goal_code for examples

txn OnCompletion
int NoOp
==
bnz handle_noop

txn OnCompletion
int OptIn
==
bnz handle_optin

txn OnCompletion
int CloseOut
==
bnz handle_closeout

txn OnCompletion
int UpdateApplication
==
bnz handle_updateapp

txn OnCompletion
int DeleteApplication
==
bnz handle_deleteapp

// Unexpected OnCompletion value. Should be unreachable.
b decline
////////////////


////////////////
// main part of code: NoOp
// 2 cases each with 2 subcases: lock (algo or asa), unlock (algo or asa)

handle_noop:

txna ApplicationArgs 0
byte "LOCK"
==
bnz handle_lock

txna ApplicationArgs 0
byte "UNLOCK"
==
bnz handle_unlock


// for debugging, useful to clear state
// txna ApplicationArgs 0
// byte "CLEAR"
// ==
// bnz handle_clear_state

// Unexpected first arg
b decline
////////////////


////////////////
// case lock
// locks consist of 2 or 3 (if optin to SYSTEM needed) main txns
// 1. call STATE dapp (to set state)
// 2. send coins to ESCROW (to lock)
// in case the coins sent are an ASA, we have a 3rd txn (but ordered 2nd):
// 3. send ALGO to ESCROW to cover unlock fees paid by ESCROW/OWNER
handle_lock:

// Set txn indices depending on whether the 1st is a SYSTEM opt-in or not
global GroupSize
int 3
>=
gtxn 0 TypeEnum
int appl
==
&&
gtxn 0 OnCompletion
int OptIn
==
&&
bnz with_opt_in
b no_opt_in

with_opt_in:
// 102: algo send txn index
int 1
store 102
// 103: app call txn index
int 2
store 103
// 104: asa send txn index
int 3
store 104
// 105: algo lock group size
int 3
store 105
b end_system_opt_in_branch

no_opt_in:
// 102: algo send txn index
int 0
store 102
// 103: app call txn index
int 1
store 103
// 104: asa send txn index
int 2
store 104
// 105: algo lock group size
int 2
store 105
b end_system_opt_in_branch

end_system_opt_in_branch:

// Check that this is the 2nd txn
txn GroupIndex
load 103
==
assert

// Check that the 1st txn is to our app
load 102
gtxns Receiver
global CurrentApplicationAddress
==
assert

// Check that 1st txn is ALGO
load 102
gtxns XferAsset
int 0
==
assert

// Check that 1st txn is payment
load 102
gtxns TypeEnum
int pay
==
assert


// Check that state is not set already
// DEBUG comment out following to test accounts that have "B" set
int 0
int 0
byte "B"
app_local_get_ex
!
assert

// locking ALGO?
global GroupSize
load 105
==
bnz handle_lock_algo

// locking ASA?
global GroupSize
load 105
int 1
+
==
bnz handle_lock_asa

// need to either be locking ALGO or ASA
b decline
////////////////


////////////////
// case lock ALGO
handle_lock_algo:

// Store energy
// fails if energy<0
load 102
gtxns Amount
global MinTxnFee
int 4
*
-
store 100

// Store assetid
load 102
gtxns XferAsset // 0
store 101

callsub set_state
b approve
////////////////


////////////////
// lock ASA case
handle_lock_asa:

// Check that 3rd txn is asset transfer
load 104
gtxns TypeEnum
int axfer
==
assert

// Check that the 3rd txn is to SYSTEM_ACCOUNT
load 104
gtxns AssetReceiver
global CurrentApplicationAddress
==
assert

// Are we opted-in to the ASA?
global CurrentApplicationAddress
load 104
gtxns XferAsset
asset_holding_get AssetBalance
bz asa_opt_in
b no_asa_opt_in

asa_opt_in:

// Check that amount is correct - this is to cover fees to unlock paid by the SYSTEM and to opt-in the SYSTEM
global MinTxnFee
int 6 // 1 for opt-in, 5 for unlock
*
int 100000 // MinASABalanceIncrease
int 2
*
+
load 102
gtxns Amount
==
assert

// opt-in SYSTEM
// pops: ... stack, amount, receiver, assetid
// pushes: none
int 0
global CurrentApplicationAddress
load 104
gtxns XferAsset
callsub send_asa

// send ALGO to Creator for opt-in
// pops: ... stack, amount, receiver
global MinTxnFee
int 100000
+
global CreatorAddress 
callsub send_algo

b continue_lock

no_asa_opt_in:

// Check that amount is correct - this is to cover fees to unlock paid by the SYSTEM
global MinTxnFee
int 5
*
load 102
gtxns Amount
==
assert

b continue_lock


continue_lock:

// Store energy
load 104
gtxns AssetAmount
store 100

// Store assetid
load 104
gtxns XferAsset
store 101

callsub set_state
b approve
////////////////


////////////////
// set state
// pops: ... stack, assetid
set_state:

// Set state speed
int 0
byte "speed"
txna ApplicationArgs 1
btoi
app_local_put

// Set state energy assetid
int 0
byte "assetid"
load 101
app_local_put

// Set state energy
// TODO need Amount of the other txn
int 0
byte "energy"
load 100
app_local_put

// Set state B
int 0
byte "B"
txna Accounts 1
app_local_put

retsub
////////////////



////////////////
// case unlock
// call STATE dapp (to check and unset state)
// unlocks consist of 3 inner txns
// 1. send coins from ESCROW back to A (unused energy)
// 2. send coins from ESCROW to FEE (service fee)
// 3. send coins from ESCROW to B (energy transfer)
handle_unlock:

// only owner can unlock
txn Sender
global CreatorAddress
==
assert

// Check B txn receiver == A set B
int 1
byte "B"
app_local_get
txna Accounts 2
==
assert

// assetid == 0 <=> ALGO only transfer
// fail if assetid not set
int 1
int 0
byte "assetid"
app_local_get_ex
assert
int 0
==
// case unlock ALGO
bnz handle_unlock_algo
// case unlock ASA
b handle_unlock_asa
////////////////


////////////////
// case unlock ALGO
handle_unlock_algo:

// Split and send energies
int 1
byte "speed"
app_local_get
txna ApplicationArgs 1 // duration
btoi
int 1
byte "energy"
app_local_get
callsub split_energy

// stack: energyA, energyFee, energyB
txna Accounts 2 // B
callsub send_algo

// stack: energyA, energyFee
global MinTxnFee
+
global CreatorAddress // Fee
callsub send_algo

// stack: energyA
txna Accounts 1 // A
callsub send_algo

callsub unset_state
b approve
////////////////


////////////////
// case unlock ASA
handle_unlock_asa:

// store assetid
int 1
byte "assetid"
app_local_get
store 101
// stack: <empty>

// Split and send energies
int 1
byte "speed"
app_local_get
txna ApplicationArgs 1 // duration
btoi
int 1
byte "energy"
app_local_get
callsub split_energy
// stack: energyA, energyFee, energyB

// pay B if B is opted-into ASA
// if B is not opted-in, SYSTEM will keep coins for now
// need to add mechanism to resolve this
// should not occur, but can happen in theory
txna Accounts 2 // B
// stack: energyA, energyFee, energyB, B
load 101 // assetid
// stack: energyA, energyFee, energyB, B, assetid
asset_holding_get AssetBalance
// stack: energyA, energyFee, energyB, AssetBalance, AssetBalanceExists
bnz pay_B
// stack: energyA, energyFee, energyB, AssetBalance
b do_not_pay_B
pay_B:
// stack: energyA, energyFee, energyB, AssetBalance
pop // asset_holding_get AssetBalance
// stack: energyA, energyFee, energyB
txna Accounts 2 // B
// stack: energyA, energyFee, energyB, B
load 101 // assetid
// stack: energyA, energyFee, energyB, B, assetid
callsub send_asa_non_zero
// stack: energyA, energyFee
b continue_unlock_asa
do_not_pay_B:
// stack: energyA, energyFee, energyB, AssetBalance
pop // asset_holding_get AssetBalance
// stack: energyA, energyFee, energyB
pop // pop energyB
// stack: energyA, energyFee

continue_unlock_asa:
// stack: energyA, energyFee

// pay CREATOR
global CreatorAddress // Creator
load 101 // assetid
// stack: energyA, energyFee, Creator, assetid
callsub send_asa_non_zero
// stack: energyA

// pay A
txna Accounts 1 // A
load 101 // assetid
// stack: energyA, A, assetid
callsub send_asa_non_zero
// stack: <empty>

// pay for CREATOR app call fee
global MinTxnFee
global CreatorAddress // Creator
// stack: MinTxnFee, Creator
callsub send_algo
// stack: <empty>

// unset state for A
callsub unset_state
b approve
////////////////



////////////////
// Cleanup
unset_state:
int 1
byte "B"
app_local_del

int 1
byte "speed"
app_local_del

int 1
byte "energy"
app_local_del

int 1
byte "assetid"
app_local_del

retsub
////////////////


////////////////
// Handle OptIn
handle_optin:
b approve
////////////////
// Handle OptIn


///////////////
// Update only by creator - for now
// TODO maybe make updating impossible for safety and assurance
handle_updateapp:

global GroupSize
int 1
==
global CreatorAddress
txn Sender
==
&&
bnz approve
b decline
///////////////


///////////////
// handle closeOut, cannot delete app, no decline
handle_closeout:
handle_deleteapp:
b decline
///////////////


////////////////
// subroutines

// A < B ? A : B
// pops: ... stack, A, B
// pushes: A xor B
min:
dup2
>=
select
retsub

// if amount != 0, send algo
// pops: ... stack, amount, receiver
// pushes: none
send_algo:
dig 1 // stack: amount, receiver, amount
bz send_algo_end_early // stack: amount, receiver
// if amount < 10000 && balance == 0, do not send (would result in error)
dig 1 // stack: amount, receiver, amount
int 10000 // stack: amount, receiver, amount, 10000
< // stack: amount, receiver, 0/1
bz send_algo_txn // stack: amount, receiver
dup // stack: amount, receiver, receiver
balance // stack: amount, receiver, balance
int 0 // stack: amount, receiver, balance, 0
== // stack: amount, receiver, 0/1
bz send_algo_txn
b send_algo_end_early // balance is zero, skip
send_algo_txn:
itxn_begin
int pay
itxn_field TypeEnum
itxn_field Receiver
itxn_field Amount
itxn_submit
retsub
send_algo_end_early:
pop
pop
retsub

// pops: ... stack, amount, receiver, assetid
// pushes: none
send_asa_non_zero:
dig 2
bz send_asa_end_early
callsub send_asa
retsub
send_asa_end_early:
pop
pop
pop
retsub

// pops: ... stack, amount, receiver, assetid
// pushes: none
send_asa:
itxn_begin
int axfer
itxn_field TypeEnum
itxn_field XferAsset
itxn_field AssetReceiver
itxn_field AssetAmount
itxn_submit
retsub

// given energy, speed and duration, calc energyA, energyFee, energyB
// pops: ... stack, speed, duration, energy
// energyB = round(energy * 0.9)
// energyFee = energy - energyB
// energyA = energy - energyB - energyFee
// pushes: energyA, energyFee, energyB
split_energy:
store 0 // balance
// stack: speed, duration
*
// stack: theo energy B
load 0
// stack: theo energy B, balance
callsub min
store 1 // energy B before fee
// stack:
load 0
load 1
// balance, energy B before fee
-
store 2 // energyA
// stack:
load 1
// stack: energy B before fee
dup
// stack: energy B before fee, energy B before fee
int 9
*
int 10
/
// stack: energy B before fee, energyB
store 3 // energyB
// stack: energy B before fee
load 3
// stack: energy B before fee, energyB
-
// stack: energyFee
load 2
swap
load 3
// stack: energyA, energyFee, energyB
retsub
////////////////

////////////////
// end branches
decline:
int 0
return

approve:
int 1
return
////////////////


////////////////
// fyi
// Txn.Accounts[0] is sender of txn
// Txn.Apps[0] is own app
////////////////